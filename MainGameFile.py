import pygame  # pygame is imported for us to make use of its mixer
import random
# random and randint are imported to allow us to generate random numbers
from random import randint
import tkinter  # tkinter is imported for us to create the GUI


class GameState:
    def __init__(self):
        """
        Initialises default values for the game

        pause is a boolean initialised as False to check if the game is
        currently paused, and is used to decide the behaviour
        of the toggle() function called by the Toggle Timer button

        score is an integer initialised as 0 to store the score of each round

        buttonRows, and buttonColumns are a list of integers which
        represent the row and column index of the grid where we
        place our buttons; they are used to reset the button positions
        when a new game starts

        buttonCoords are a nested list of coordinates which represent
        the row and column indices of the grid where we place
        our buttons; they are shuffled using randompos() and
        are used to set the random button positions after every press

        dispexpress is an empty string. It holds the user input,
        and is used to set the tkinter string variable
        equation, which will display the user's input in the
        GUI

        testword is an empty string used to hold the equation
        generated by newWord(), and is what the user's input
        will be verified against on every game.press(num) call.
        It is also used to set the tkinter string variable
        testequation, which will display the equation to be
        matched in the GUI

        turn is an integer initialised as -1. This is because
        the value of turn is used to refer to the index of the
        string which holds the user's most recent input. As turn
        increases with every game.press(num), and is reset on the end
        of each round using resetGame(), it serves to keep track
        of the user's current input index in the string.

        timeleft is an integer initialised as 30. It is used to set
        the time left on the timer, and is displayed on the GUI.

        highestscore is the highestscore attained on the current
        instance of the app. It is initialised as an integer, zero.

        congratsplayedbefore is a boolean initialised as false by default
        It is reset whenever a new game is started by resetGame(). If
        congratsplayedbefore is true, then no congratulation sound will
        be played for the increase of score above the highscore. If it is
        false, the congratulatory sound will play as long as the user scores
        and the current score exceeds the latest highscore.
        """
        self.pause = False
        self.score = 0
        self.buttonRows = (2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5)
        self.buttonColumns = (0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1)
        self.buttonCoords = [
            [2, 0],
            [2, 1],
            [2, 2],
            [2, 3],
            [3, 0],
            [3, 1],
            [3, 2],
            [3, 3],
            [4, 0],
            [4, 1],
            [4, 2],
            [4, 3],
            [5, 0],
            [5, 1],
        ]
        # string to store the user's input
        self.dispexpress = ""

        # string to store the correct answer
        self.testword = ""

        # turn is used to refer to the index of the input
        # and the correct answer to compare the two
        self.turn = -1

        # timeleft is used for the game timer
        self.timeleft = 30

        # highestscore is to store the highscore
        self.highestscore = 0

        # congratsplayedbefore boolean is to ensure that the highscore message
        # is only played once per round upon the
        # beating of the previous highscore
        self.congratsplayedbefore = False

    def randompos(self):
        """
        randompos uses the random library to shuffle the list buttonCoords,
        and calls window.update() so that the GUI re-renders the components
        to reflect the new posiitons of the button

        It is called by game.press(num)
        """
        random.shuffle(self.buttonCoords)
        window.update()

    def toggle(self):
        """
        toggle is called by the "Toggle Timer" button
        It looks at the pause variable, and sets it to
        the opposite of itself using 'not'

        Thereafter, it checks if the new value of
        pause is true. If it is true, it calls
        stopticksound(), which stops the ticking
        noise that is made when the timleft reaches
        below 15. If it has not yet reached below 15,
        nothing happens when stopticksound() is
        called.

        If the new value of pause is false, it
        checks if the timeleft variable is below
        15. If it is, it calls ticksound() to start
        playing the ticking sound.
        """
        self.pause = not self.pause
        if self.pause:
            self.stopticksound()
        if not self.pause:
            if self.timeleft < 15:
                self.ticksound()

    def resetGame(self):
        """
        Resets the game, called by the "New Game" button
        or upon wrong input by user.

        Checks if the int self.score is more than int
        self.highestscore, then, if true,checks the
        boolean value of self.congratsplayedbefore

        If self.congratsplayedbefore is false, calls
        self.highscoresound() to play the new highscore
        sound, and sets self.congratsplayedbefore
        to true so that it will not be called
        again during the same game.

        sets self.testword as an empty string,
        and calls the self.newWord()
        function to generate a new string that
        is assigned to self.testword

        sets self.dispexpress as an empty string,
        and sets the tkinter string variable
        equation as self.dispexpress, so that the
        user input is displayed as empty
        to the user in the GUI

        calls self.stopticksound() to stop the ticking
        sound if it is currently played

        sets int self.timeleft to 30, to reset the timer
        sets int self.turn to -1, to reset the turn/ user
        input index counter
        """

        if self.score > self.highestscore:
            if not self.congratsplayedbefore:
                self.highscoresound()
                self.congratsplayedbefore = True
            self.highestscore = self.score
            highscore.set(self.highestscore)

        self.testword = ""
        self.newWord()

        self.dispexpress = ""
        equation.set(self.dispexpress)

        self.stopticksound()
        self.timeleft = 30
        self.turn = -1

    def scoreReset(self):
        """
        Called by the resetScore() function

        Resets the self.score variable to 0 so that the new round starts
        with score of 0

        Sets the boolean self.congratsplayedbefore to False, so that
        in the new game, if the current highscore is beaten,  the
        congratulatory sound plays
        """

        self.score = 0
        self.congratsplayedbefore = False

    def resetScore(self):
        """
        Called by "New Game" button, and by game.press(num) when the user input
        does not match the given equation

        Calls scoreReset() to reset self.score and self.congratsplayedbefore

        Sets the tkinter integer variable gamescore to self.score so
        that the current score displayed on the GUI is reset to 0
        """
        game.scoreReset()
        gamescore.set(self.score)

    def generateNewWord(self):
        """
        Called by newWord(), this function declares
        a probdecider boolean value as true

        This function makes use of the random library, specifically
        the randint function

        Then it creates a list of operators as strings named
        randops

        It then creates a string variable generatedWord, and
        gives it a random integer between 0 and 999, converted
        to a string, a random operator using randint to provide
        a random index between 0 and 3 to reference the randops
        list, and another random integer between 0 and 999, converted
        to a string

        Then, a while loop runs while probdecider is true, which will
        continue generating a longer equation by returning a random
        operator using randint to provide
        a random index between 0 and 3 to reference the randops
        list, and another random integer between 0 and 999, converted
        to a string, and concatenating that to generatedWord

        The function checks that the length of generatedWord
        does not exceed 35, and if it does changes probdecider
        to false so that the while loop exits, and generatedWord
        is returned.

        This ensures that the length of the equation generated
        will be able to fit in our GUI

        If generatedWord does not exceed the length,
        it uses randint(0,100) to return an integer between
        0 and 100. Then it checks whether the integer, named probs,
        is less than 75.

        If it is, probdecider is set as true, and the while loop
        continues.

        Else, probdecider is set as false, exiting the while loop.

        In short, there is a 75% chance during each loop that the
        loop continues unless the string exceeds the max length.
        """
        probdecider = True
        randops = ["+", "-", "รท", "x"]
        generatedWord = (
            str(randint(0, 999))
            + randops[(randint(0, 3))]
            + str(randint(0, 999))
        )
        while probdecider:
            generatedWord = generatedWord + \
                randops[(randint(0, 3))] + str(randint(0, 999))
            if len(generatedWord) > 35:
                probdecider = False
            else:
                probs = randint(0, 100)
                if probs < 75:
                    probdecider = True
                else:
                    probdecider = False
        return generatedWord

    def newWord(self):
        """
        Calls the generateNewWord() function and assigns the
        returned value to testword

        Sets the tkinter string variable testequation as the
        testword variable so that the equation to be matched
        is displayed on the GUI for the user
        """
        self.testword = self.generateNewWord()
        testequation.set(self.testword)

    def press(self, num):
        """
        Takes user input based as num, updates the expression displayed,
        by concatenating it to dispexpress, and setting equation as
        dispexpress


        The function then calls randompos() which shuffles the coords of
        the buttons, replacing them in random positions.

        The function also adds 1 to turn so that it can be used to refer to
        an index in dispexpress and testword, and compare their values.

        If the value is the same, it calls bing() which plays a congratulatory
        sound

        Then it checks if the length of disexpress is equal to the length of
        testword, to decide whether the game should be reset

        If it is, it checks if the score is above 10. If it is, it plays
        an annoying sound by calling congratsunplayable()

        Then it adds 1 to the current socre, plays a congratulatory sound by
        calling congratsplayable() and sets the gamescore as the current score,
        and then resets the game by calling resetGame()

        If the user input does not match,
        it plays a sad sound by calling bong() and calls
        resetScore() and resetGame() to reset the score and
        game.

        Parameters:
        ----
        num<str>: User input to displayed expression

        """
        self.dispexpress = self.dispexpress + num
        equation.set(self.dispexpress)
        self.randompos()
        self.turn += 1
        if self.dispexpress[self.turn] == self.testword[self.turn]:
            self.bing()
            if len(self.dispexpress) == len(self.testword):
                if self.score > 10:
                    self.congratsunplayable()
                self.score += 1
                self.congratsplayable()
                gamescore.set(self.score)
                self.resetGame()
        else:
            self.bong()
            self.resetScore()
            self.resetGame()

    # background music
    """
    The functions below load the respective .wav files
    for our audio, and plays them.

    Where used, the loops = -1 means that the audio
    loops ad infinitum

    Audio is played using the pygame mixer module.

    For the background music, we use the mixer.music, which
    streams the music from kahootbgm.wav in small chunks
    on its own dedicated channel

    For the sound effects, we use a new mixer.Channel(num) where
    num specifies the channel, to load and play the effects.

    This is because pygame.mixer only supports one soundfile playing
    on a given channel at any time.

    These sound functions are called during the game to
    start sound effects or music.

    The wav files should be stored in the root directory
    of the application.
    """

    def bgm(self):
        pygame.mixer.music.load("kahootbgm.wav")
        pygame.mixer.music.play(loops=-1)

    # correct answer sound
    def bing(self):
        pygame.mixer.Channel(0).play(pygame.mixer.Sound("ding.wav"))

    # wrong answer sound
    def bong(self):
        pygame.mixer.Channel(1).play(pygame.mixer.Sound("shortbuzz.wav"))

    # timer runs out sound
    def buzz(self):
        pygame.mixer.Channel(2).play(pygame.mixer.Sound("buzz.wav"))

    # ticking sound for timer
    def ticksound(self):
        pygame.mixer.Channel(3).play(
            pygame.mixer.Sound("ticksound.wav"), loops=-1)

    # stop ticking sound for timer;
    # use by the pause button, and also upon timer reset
    def stopticksound(self):
        pygame.mixer.Channel(3).stop()

    # simple sound to denote score increase
    def congratsplayable(self):
        pygame.mixer.Channel(4).play(
            pygame.mixer.Sound("congratsplayable.wav"))

    # sound to denote score increase for each
    # point above 11 to annoy the player
    def congratsunplayable(self):
        pygame.mixer.Channel(5).play(
            pygame.mixer.Sound("congratsunplayable.wav"))

    # sound to be played upon first beating of the highscore
    def highscoresound(self):
        pygame.mixer.Channel(6).play(pygame.mixer.Sound("highscore.wav"))


if __name__ == "__main__":
    """
    We create a new tkinter Tk root widget using tkinter.Tk()
    and name it window

    Thereafter, using window.title(), window.geometry, and
    window.resizable(), we set the name of the window,
    its size, and make it unresizable, respectively.

    Then, we create a new GameState object, named game
    by using GameState()

    We then create tkinter string variables, for equation
    and testequation, to hold the user input and the correct
    equation respectively

    We create tkinter int variables, for the current game,
    and highscore, named gamescore and highscore respectively

    We call the newWord() function, to set a new equation

    We call the pygame.mixer.init() function to initialise
    the mixer, so that we can call game.bgm() which, like
    our other sound effect functions, depend
    on the mixer being inititalised.

    game.bgm() starts playing out background music
    """
    window = tkinter.Tk()
    window.title("Equation Matching Game")
    window.geometry("480x300")
    window.resizable(False, False)
    game = GameState()
    equation = tkinter.StringVar()
    testequation = tkinter.StringVar()
    gamescore = tkinter.IntVar()
    highscore = tkinter.IntVar()
    game.newWord()
    pygame.mixer.init()
    game.bgm()

    # Function to be called to randomly replace the buttons in the grid
    def replaceButtons():
        """
        This function references the buttonCoords
        nested list, which contains the coordinates
        of the grid where our user input buttons
        can lie.

        Calling the function re-renders and replaces
        the button according to the positions specified
        in the row and column arguments of the grid() functions
        below

        As randompos() is run, the values referenced by the
        indices of buttonCoords changes, and so the buttons
        are rerendered in their new, random positions

        This function is called by press(), so that buttons
        are replaced after every user input
        """
        button1.grid(
            row=game.buttonCoords[0][0],
            column=game.buttonCoords[0][1])
        button2.grid(
            row=game.buttonCoords[1][0],
            column=game.buttonCoords[1][1])
        button3.grid(
            row=game.buttonCoords[2][0],
            column=game.buttonCoords[2][1])
        button4.grid(
            row=game.buttonCoords[3][0],
            column=game.buttonCoords[3][1])
        button5.grid(
            row=game.buttonCoords[4][0],
            column=game.buttonCoords[4][1])
        button6.grid(
            row=game.buttonCoords[5][0],
            column=game.buttonCoords[5][1])
        button7.grid(
            row=game.buttonCoords[6][0],
            column=game.buttonCoords[6][1])
        button8.grid(
            row=game.buttonCoords[7][0],
            column=game.buttonCoords[7][1])
        button9.grid(
            row=game.buttonCoords[8][0],
            column=game.buttonCoords[8][1])
        button10.grid(
            row=game.buttonCoords[9][0],
            column=game.buttonCoords[9][1])
        button11.grid(
            row=game.buttonCoords[10][0],
            column=game.buttonCoords[10][1])
        button12.grid(
            row=game.buttonCoords[11][0],
            column=game.buttonCoords[11][1])
        button13.grid(
            row=game.buttonCoords[12][0],
            column=game.buttonCoords[12][1])
        button14.grid(
            row=game.buttonCoords[13][0],
            column=game.buttonCoords[13][1])

    def resetButtons():
        """
        This function references the butttonRows and
        buttonColumns list, which contains the
        row and column coordinates
        of the grid where our user input buttons
        can lie.

        Calling the function re-renders and replaces
        the button according to the positions specified
        in the row and column arguments of the grid() functions
        below

        As buttonRows and buttonColumns are tuples,
        they are immutable, and so provide us a constant
        reference by which we can reset the positions of the
        buttons to their default

        This function is called by the New Game button, and by tock()
        when timeleft == 0, so that
        buttons are reset for every new game
        """
        button1.grid(
            row=game.buttonRows[0],
            column=game.buttonColumns[0])
        button2.grid(
            row=game.buttonRows[1],
            column=game.buttonColumns[1])
        button3.grid(
            row=game.buttonRows[2],
            column=game.buttonColumns[2])
        button4.grid(
            row=game.buttonRows[3],
            column=game.buttonColumns[3])
        button5.grid(
            row=game.buttonRows[4],
            column=game.buttonColumns[4])
        button6.grid(
            row=game.buttonRows[5],
            column=game.buttonColumns[5])
        button7.grid(
            row=game.buttonRows[6],
            column=game.buttonColumns[6])
        button8.grid(
            row=game.buttonRows[7],
            column=game.buttonColumns[7])
        button9.grid(
            row=game.buttonRows[8],
            column=game.buttonColumns[8])
        button10.grid(
            row=game.buttonRows[9],
            column=game.buttonColumns[9])
        button11.grid(
            row=game.buttonRows[10],
            column=game.buttonColumns[10])
        button12.grid(
            row=game.buttonRows[11],
            column=game.buttonColumns[11])
        button13.grid(
            row=game.buttonRows[12],
            column=game.buttonColumns[12])
        button14.grid(
            row=game.buttonRows[13],
            column=game.buttonColumns[13])

    # Equation keyed in by user
    equation_field = tkinter.Label(
        window, textvariable=equation, font="Helvetica 20", fg="green"
    )
    equation_field.grid(columnspan=4, ipadx=70)

    # Equation to be matched by user
    answer_field = tkinter.Label(
        window,
        textvariable=testequation,
        font="Helvetica 15",
    )
    answer_field.grid(columnspan=4, ipadx=70)

    # User's current score
    user_score = tkinter.Label(
        window, text="Score:", font="Helvetica 20", fg="green"
    ).grid(row=6, column=0)
    user_score_field = tkinter.Label(
        window, textvariable=gamescore, font="Helvetica 20", fg="green"
    ).grid(row=6, column=1)

    # High Score
    high_score = tkinter.Label(
        window, text="Highscore:", font="Helvetica 20").grid(
        row=7, column=0
    )
    high_score_field = tkinter.Label(
        window, textvariable=highscore, font="Helvetica 20"
    ).grid(row=7, column=1)

    # Game timer
    gametimer = tkinter.Label(
        window, text=game.timeleft, fg="firebrick1", font="Helvetica 40")
    gametimer.grid(column=0, row=0)

    # Instructions for the game
    instructions = tkinter.Label(
        window,
        text=(
            "Press the buttons to re-create the equation shown "
            "before the timer runs out"),
        font="Helvetica 14",
        fg="firebrick1",
    )
    instructions.grid(row=8, column=0, columnspan=4)

    # Set up buttons in GUI
    """
    The code below creates buttons for the GUI
    It specifies the position of the buttons on the grid,
    as well as the corresponding command called by each button

    Each button calls an anonymous function denoted by lambda
    which calls the respective functions for the button

    The buttons are the only way that the user can give input
    to the program
    """
    button1 = tkinter.Button(
        window,
        text="1",
        fg="black",
        command=lambda: [game.press("1"), replaceButtons()],
        font="Helvetica 25",
        width="5",
    )
    button1.grid(row=game.buttonRows[0], column=game.buttonColumns[0])
    button2 = tkinter.Button(
        window,
        text="2",
        fg="black",
        command=lambda: [game.press("2"), replaceButtons()],
        font="Helvetica 25",
        width="5",
    )
    button2.grid(row=game.buttonRows[1], column=game.buttonColumns[1])
    button3 = tkinter.Button(
        window,
        text="3",
        fg="black",
        command=lambda: [game.press("3"), replaceButtons()],
        font="Helvetica 25",
        width="5",
    )
    button3.grid(row=game.buttonRows[2], column=game.buttonColumns[2])
    button4 = tkinter.Button(
        window,
        text="+",
        fg="black",
        command=lambda: [game.press("+"), replaceButtons()],
        font="Helvetica 25",
        width="5",
    )
    button4.grid(row=game.buttonRows[3], column=game.buttonColumns[3])
    button5 = tkinter.Button(
        window,
        text="4",
        fg="black",
        command=lambda: [game.press("4"), replaceButtons()],
        font="Helvetica 25",
        width="5",
    )
    button5.grid(row=game.buttonRows[4], column=game.buttonColumns[4])
    button6 = tkinter.Button(
        window,
        text="5",
        fg="black",
        command=lambda: [game.press("5"), replaceButtons()],
        font="Helvetica 25",
        width="5",
    )
    button6.grid(row=game.buttonRows[5], column=game.buttonColumns[5])
    button7 = tkinter.Button(
        window,
        text="6",
        fg="black",
        command=lambda: [game.press("6"), replaceButtons()],
        font="Helvetica 25",
        width="5",
    )
    button7.grid(row=game.buttonRows[6], column=game.buttonColumns[6])
    button8 = tkinter.Button(
        window,
        text="-",
        fg="black",
        command=lambda: [game.press("-"), replaceButtons()],
        font="Helvetica 25",
        width="5",
    )
    button8.grid(row=game.buttonRows[7], column=game.buttonColumns[7])
    button9 = tkinter.Button(
        window,
        text="7",
        fg="black",
        command=lambda: [game.press("7"), replaceButtons()],
        font="Helvetica 25",
        width="5",
    )
    button9.grid(row=game.buttonRows[8], column=game.buttonColumns[8])
    button10 = tkinter.Button(
        window,
        text="8",
        fg="black",
        command=lambda: [game.press("8"), replaceButtons()],
        font="Helvetica 25",
        width="5",
    )
    button10.grid(row=game.buttonRows[9], column=game.buttonColumns[9])
    button11 = tkinter.Button(
        window,
        text="9",
        fg="black",
        command=lambda: [game.press("9"), replaceButtons()],
        font="Helvetica 25",
        width="5",
    )
    button11.grid(row=game.buttonRows[10], column=game.buttonColumns[10])
    button12 = tkinter.Button(
        window,
        text="x",
        fg="black",
        command=lambda: [game.press("x"), replaceButtons()],
        font="Helvetica 25",
        width="5",
    )
    button12.grid(row=game.buttonRows[11], column=game.buttonColumns[11])
    button13 = tkinter.Button(
        window,
        text="0",
        fg="black",
        command=lambda: [game.press("0"), replaceButtons()],
        font="Helvetica 25",
        width="5",
    )
    button13.grid(row=game.buttonRows[12], column=game.buttonColumns[12])
    button14 = tkinter.Button(
        window,
        text="รท",
        fg="black",
        command=lambda: [game.press("รท"), replaceButtons()],
        font="Helvetica 25",
        width="5",
    )
    button14.grid(row=game.buttonRows[13], column=game.buttonColumns[13])
    startbutton = tkinter.Button(
        window,
        text="New Game",
        fg="black",
        command=lambda: [game.resetGame(), game.resetScore(), resetButtons()],
    )
    startbutton.grid(row=6, column=2)
    endbutton = tkinter.Button(
        window, text="Toggle Timer", fg="black",
        command=lambda: [game.toggle()]
    )
    endbutton.grid(row=6, column=3)

    # TIMER function
    """
    The timer function below makes use of the built in
    after function in the tkinter window

    This allows us to specify a time in ms before another function
    is called.
    """
    def tock():
        """
        Tock() will check if the game is paused using the pause variable

        If the game is paused, it will set the timeleft variable to itself,
        in essence, freezing the timer

        Otherwise, it will subtract 1 from timeleft, and use the
        config() function in tkinter to update the
        property of gametimer to display
        the new value of timeleft

        Then it checks if timeleft is 15.
        If timeleft is 15, it calls ticksound()
        which plays a ticking sound

        Else it checks if timeleft is 0.
        if timeleft is 0, it calls stopticksound()
        to stop the ticking sound, calls buzz() to
        make a buzzing sound, and calls resetGame()
        to reset the game
        """

        if game.pause:
            game.timeleft = game.timeleft
        else:
            game.timeleft -= 1
            gametimer.config(text=game.timeleft)
            if game.timeleft == 15:
                game.ticksound()
            if game.timeleft == 0:
                game.stopticksound()
                game.buzz()
                game.resetGame()
                resetButtons()

    def tick():
        """
        In tick(), we specify the time in the after() function
        as 1000ms

        This means that after 1000ms, tick() will call tock(),
        as long as timeleft > 0
        """

        if game.timeleft > 0:
            tock()
            window.after(1000, tick)

    tick()
    """
    Calls the tick() function to initiate the timer
    """

    window.mainloop()
    """
    This mainloop() function starts the tkinter event loop

    It listens for buttonpresses, and keypresses, and blocks
    any code that comes after it from being run until the GUI is closed
    """
